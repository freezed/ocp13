# Implémentation de l'_extrême programming_

Ce projet à été construit pour s'approcher le plus possible d'une mission telle que pourrait la mener un développeur indépendant (ou une équipe très réduite).

Dans ce contexte une des demandes était d'essayer d'appliquer au mieu les principes de _l'extrem-programming_.

#### _[Mes commentaires sont préfixé par l'aisance d'application dans ce projet]_

# Principes

## Client sur site

`[difficile]` : Bien qu'ayant de [véritables clients][client] pour ce projet, les principaux freins au travail _sur site_ ont été les suivantes :

* tous idénpendants (disponibilité)
* lieux de travail tournant (non-sédentaire)


## Jeu du planning ou planning poker

`[facile]` : Au préalable le travail à été découpé en _fonctionnalités_ puis organisé grossièrement dans un [kanban][kanban]. Dans ces conditions, si on ajoute le fait de développer seul, il est aisé de faire un point quotidien (ou à la livraison d'une fonctionnalité), pour ajuster la feuille de route.


## Intégration continue

`[facile]` : Le pacours nous présente des outils accessibles, bien conçus, hautement inter-connectable et efficaces. C'est du travail de config, mais ensuite c'est transparent!


## Petites livraisons

`[facile]` : C'est une habitude que j'avais déjà prise très tôt dans le parcours, de temps en temps on s'enflamme un peu, mais avec l'expérience grandissante, ça devient de plus en plus facile de concevoir le projet comme un puzzle.


## Rythme soutenable

`[difficile]` : Bon ça c'est lié au timing du parcours… j'aurai volontier profiter de quelques semaine supplémentaires pour avoir un rythme plus modéré, mais il m'aura été très difficile de tenir un planning strict pour les 8 premiers mois du parcours.


## Tests unitaires/fonctionnels

`[facile]` : Le déclic à pu se faire pour moi durant ce parcours, de plus c'était un de mes objectifs personnel dans ce parcours : _maîtriser le TDD_. Il me reste bien entendu beaucoup à apprendre dans ce domaine, mais le cap est bon. Et pour ce projet l'objectif d'une couverture des tests à 100% a été tenu.

## Conception simple

`[modéré]` : C'est arrivé au début de ce projet : _Django_ s'apprécie avec un découpage applicatif! l'UML permet aussi de rationnaliser les fonctionnalités et leurs relations.

## Refactoring (ou remaniement du code)

`[modéré]` : Le principe n'à rien de difficile en soit, mais dans ce projet de longue haleine, il y a d'abord un prototype à construire avec un ensemble de fonctionnalité avant de pouvoir itérer à nouveau et refactorer du code.

## Appropriation collective du code

`[difficile]` : Bon, en développant seul aussi c'est compliqué…

## Convention de nommage

`[facile]` : _Python_ d'une part et _Django_ ensuite sont deux cadre de travails qui prone les convention avant la configuration.

## Pair-programming

`[difficile]` :  Sans commentuires supplémentaires


[client]: https://github.com/freezed/ocp13/blob/master/README.md#contexte-utilisateur
[kanban]: https://github.com/freezed/ocp13/projects/1
